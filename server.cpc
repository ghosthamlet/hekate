/*
Copyright (c) 2009-2011 by Pejman Attar, Yoann Canal, Juliusz Chroboczek and
                      Gabriel Kerneis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <cpc/cpc_runtime.h>
#include <cpc/cpc_lib.h>

#include "util.h"
#include "hashtable.h"
#include "parse.h"
#include "server.h"
#include "torrent.h"
#include "tracker.h"
#include "list.h"
#include "io.h"

#define BUF_LENGTH 2048
#define DIR_LEN 512

static cpc_condvar *choke_cond;

static int numpeers = 0;
static int numunchoked = 0;
static int maxpeers;
int peer_port = 6969;
int maxunchoked = 50;
int initial_credit = 1024 * 1024;
int max_unchoked_time = 5 * 60;

/* TODO: faire un truc efficace (table de hachage ou avl, ou une combinaison des
   deux) */
struct peer_lst {
    struct peer *peer;
    cpc_handle_t client_socket;
    struct peer_lst *next;
};
static struct peer_lst *peers = NULL;
static struct peer_lst *last_searched = NULL;

static int add_peer(cpc_handle_t sock)
{
#ifdef __unix__
    if(sock->cpch_handle >= fd_max) {
        struct peer *new_peers;
        int new_fd_max = sock->cpch_handle + 10;

        debugf(2, "%3d beyond fd_max -- resizing\n", sock->cpch_handle);
        new_peers = realloc(peers, new_fd_max * sizeof(struct peer));
        if(new_peers == NULL) {
            perror("realloc");
            debugf(1, "%3d beyond fd_max -- dropping\n", sock->cpch_handle);
            return -1;
        }
        memset(new_peers + fd_max, 0,
               (new_fd_max - fd_max) * sizeof(struct peer));
        peers = new_peers;
        fd_max = new_fd_max;
    }
    numpeers++;
    return 0;
#else
    struct peer_lst *element = malloc(sizeof(*element));
    if(element == NULL) return -1;
    element->peer = calloc(1, sizeof(struct peer));
    if(element->peer == NULL) {
        free(element);
        return -1;
    }
    element->next = peers;
    element->client_socket = sock;
    peers = element;
    numpeers++;
    last_searched = element;
    return 0;
#endif
}

static int
remove_peer(cpc_handle_t sock)
{
#ifdef __unix
    memset(GET_PEER(sock), 0, sizeof(struct peer));
#else
    struct peer_lst *prev = NULL;
    struct peer_lst *curr = peers;
    if(last_searched != NULL && last_searched->client_socket == sock)
        last_searched = NULL;
    if(curr->client_socket == sock) {
        peers = peers->next;
        free(curr->peer);
        free(curr);
        goto done;
    }
    while(curr->next) {
        prev = curr;
        curr = curr->next;
        if(curr->client_socket == sock) {
            prev->next = curr->next;
            free(curr->peer);
            free(curr);
            goto done;
        }
    }
    return -1;
 done:
#endif
    numpeers--;
    return 0;
}

static struct peer *get_peer(cpc_handle_t sock)
{
    struct peer_lst *curr = peers;
    if(last_searched != NULL && last_searched->client_socket == sock)
        return last_searched->peer;
    for(curr = peers; curr != NULL; curr = curr->next)
        if(curr->client_socket == sock) {
            last_searched = curr;
            return curr->peer;
        }
    return NULL;
}
//(unix) #define GET_PEER(cpchandle) (&peers[cpchandle->cpch_handle])
#define GET_PEER(cpchandle) get_peer(cpchandle)

#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#define MIN(x, y) ((x) >= (y) ? (y) : (x))

static cps int
send_message_2(cpc_handle_t sock, int id,
               char *body1, int bodylen1, char *body2, int bodylen2)
{
    unsigned char buf[5];
    cpc_iobuf iobuf[3];
    int i, rc;

    debugf(10, "%3d -> type = %d, length = %d\n",
           sock->cpch_handle, id, bodylen1 + bodylen2 + 1);

    DO_HTONL(buf, bodylen1 + bodylen2 + 1);
    buf[4] = id;

    i = 0;

    cpc_iobuf_set(&iobuf[i], buf, 5);
    i++;

    if(bodylen1 > 0) {
        cpc_iobuf_set(&iobuf[i], body1, bodylen1);
        i++;
    }

    if(bodylen2 > 0) {
        cpc_iobuf_set(&iobuf[i], body2, bodylen2);
        i++;
    }

    rc = cpc_sendv(sock, iobuf, i);
    if(rc < 5)
        return -1;

    return 1;
}

static cps int
send_message(cpc_handle_t sock, int id, char *body, int bodylen)
{
    return send_message_2(sock, id, body, bodylen, NULL, 0);
}

static cps int
send_message_h(cpc_handle_t sock, char *head, int headlen,
               int id, char *body, int bodylen)
{
    unsigned char buf[5];
    cpc_iobuf iobuf[3];
    int i, rc;

    debugf(10, "%3d -> h=%d, type = %d, length = %d\n",
           sock->cpch_handle, headlen, id, bodylen + 1);

    DO_HTONL(buf, bodylen + 1);
    buf[4] = id;

    i = 0;

    if(headlen > 0) {
        cpc_iobuf_set(&iobuf[i], head, headlen);
        i++;
    }

    cpc_iobuf_set(&iobuf[i], buf, 5);
    i++;

    if(bodylen > 0) {
        cpc_iobuf_set(&iobuf[i], body, bodylen);
        i++;
    }

    rc = cpc_fullsendv(sock, iobuf, i);
    if(rc < 5)
        return -1;

    return 1;
}

static cps int
send_bitfield(cpc_handle_t sock, struct torrent *t, char *head, int headlen)
{
    int length = 0;
    unsigned char *buf= NULL;
    int rc;

    length = (t->num_chunks - 1) / 8 + 1;

    buf = malloc(length);
    if(!buf) {
        perror("(send_bitfield)malloc");
        return -1;
    }

    memset(buf, 0xFF, length - 1);
    if(t->num_chunks % 8 == 0)
        buf[length - 1] = 0xFF;
    else
        buf[length - 1] = (0xFF00 >> (t->num_chunks % 8)) & 0xFF;

    rc = send_message_h(sock, head, headlen, 5, buf, length);
    if(rc < 0) {
        print_error("(send_bitfield)cpc_message");
        free(buf);
        return -1;
    }

    free(buf);
    return 1;
}

static cps int
send_choke(cpc_handle_t sock)
{
    int rc;

    rc = send_message(sock, 0, NULL, 0);
    if(rc < 0) {
        perror("(send_choke)cpc_full_write");
        return -1;
    }
    return 0;
}

static cps int
send_unchoke(cpc_handle_t sock)
{
    int rc;

    rc = send_message(sock, 1, NULL, 0);
    if(rc < 0) {
        perror("(send_unchoke)cpc_full_write");
        return -1;
    }
    return 0;
}

static cps int
send_dht_port(cpc_handle_t sock, unsigned short port)
{
    int rc;
    unsigned char buf[2];

    DO_HTONS(buf, port);

    rc = send_message(sock, 9, buf, 2);
    if(rc < 0) {
        perror("(send_dht_port)cpc_full_write");
        return -1;
    }
    return 0;
}

static cps int
send_ltep_message(cpc_handle_t sock, int id, char *body, int bodylen)
{
    char buf[1];
    buf[0] = id;

    return send_message_2(sock, 20, buf, 1, body, bodylen);
}

/* Return global IPv6, with caching.  Careful, this returns a pointer to
   a static buffer. */
static cps unsigned char *
global_ipv6(void)
{
    static unsigned char ipv6[16];
    static time_t ipv6_time = 0;
    static int have_ipv6 = 0;
    time_t now = time(NULL);

    /* Re-check every half hour */
    if(ipv6_time < now - 1800) {
        int rc, addrlen;
        addrlen = 16;
        cpc_detached {
            rc = find_global_address(AF_INET6, ipv6, &addrlen);
        }
        if(rc >= 0 && addrlen == 16)
            have_ipv6 = 1;
        else
            have_ipv6 = 0;
        ipv6_time = now;
    }

    if(have_ipv6)
        return ipv6;
    else
        return NULL;
}

static cps int
send_ltep_handshake(cpc_handle_t sock, unsigned short port)
{
    int rc;
    unsigned char buf[100];
    const char *hekate = "Hekate 0.0";
    unsigned char *ipv6 = noipv6 ? NULL : global_ipv6();

    rc = snprintf(buf, 100, "d%s1:pi%ue1:v%d:%se",
                  ipv6 ? "4:ipv616:................" : "",
                  port, (int)strlen(hekate), hekate);
    if(rc < 0 || rc > 100)
        return -1;

    if(ipv6)
        memcpy(buf + 10, ipv6, 16);

    rc = send_ltep_message(sock, 0, buf, rc);
    if(rc < 0) {
        perror("(send_ltep_handshake)cpc_full_write");
        return -1;
    }
    return 0;
}

static int
find_chunk(struct torrent *t, uint64_t begin, uint64_t length,
           int *first_return, int *last_return,
           uint64_t *offset_return, uint64_t *last_len_return)
           __attribute__((cpc_no_retain))
{
    int i, first = -1, last = -1;
    uint64_t offset, last_len;
    struct file *f;

    for(i = 0; i < t->num_files; i++) {
        f = t->files[i];
        if(f->offset <= begin) {
            first = i;
        }
        if(f->offset + f->length >= begin + length) {
            last = i;
            break;
        }
    }

    if(first < 0 || last < 0)
        return -1;

    assert(last >= first);
    assert(begin >= t->files[first]->offset);
    assert(begin + length <= t->files[last]->offset + t->files[last]->length);

    offset = begin - t->files[first]->offset;
    /* Chunk beyond last file */
    if(offset > t->files[first]->length)
        return -1;
    if(first == last)
        last_len = length;
    else
        last_len = begin + length - t->files[last]->offset;

    if(first_return)
        *first_return = first;
    if(last_return)
        *last_return = last;
    if(offset_return)
        *offset_return = offset;
    if(last_len_return)
        *last_len_return = last_len;

    return 1;
}

static cps int
send_multi_chunk(cpc_handle_t sock, struct chunk *chunk,
                 int first, int last, uint64_t offset)
{
    unsigned char buf[8];
    unsigned char *body;
    int pos, i, len, rc;
    int64_t rc64;
    cpc_handle_t file = NULL;
    struct torrent *t = GET_PEER(sock)->t;

    body = malloc(chunk->length);
    if(!body) {
        perror("(send_multi_chunk)malloc");
        return -1;
    }

    pos = 0;
    for(i = first; i <= last; i++) {
        file = cpc_open_file_std(t->files[i]->path, O_RDONLY);
        if(file == NULL) {
            print_error("open file");
            goto fail;
        }
        if(i == first) {
            len = t->files[i]->length - offset;
            rc64 = cpc_read_at(file, body, len, offset);
        } else {
            len = MIN(chunk->length - pos, t->files[i]->length);
            rc64 = cpc_read(file, body + pos, len);
        }
        if(rc64 < 0)
            goto read_fail;
        cpc_close_handle(file);
        pos += len;
    }

    debugf(3, "%3d send chunk: length=%d, offset=%lld\n",
           sock->cpch_handle, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    DO_HTONL(buf + 0, chunk->offset);
    DO_HTONL(buf + 4, chunk->begin);

    /* pos may be smaller than chunk->length, if the chunk extended beyond
       the end of the torrent. */
    rc = send_message_2(sock, 7, buf, 8, body, pos);
    if(rc < 0) {
        perror("(send_chunk)write");
        goto fail;
    }

    debugf(3, "%3d sent chunk: length=%d, offset=%lld\n",
           sock->cpch_handle, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    t->uploaded += chunk->length;
    GET_PEER(sock)->credit -= chunk->length;
    assert(GET_PEER(sock)->credit >= 0 &&
           GET_PEER(sock)->credit < initial_credit);

    free(body);
    return 0;

 read_fail:
    print_error("read at");
    cpc_close_handle(file);
 fail:
    free(body);
    return -1;
}

static cps int
unchoke_peer(cpc_handle_t sock)
{
    int rc;

    assert(numunchoked <= numpeers);
    assert(!GET_PEER(sock)->unchoked);

    debugf(2, "%3d unchoke\n", sock);
    rc = send_unchoke(sock);
    if(rc < 0)
        return -1;
    numunchoked++;
    GET_PEER(sock)->unchoked = 1;
    GET_PEER(sock)->credit = initial_credit;
    GET_PEER(sock)->unchoke_time = time(NULL);
    return 1;
}

static cps int
choke_peer(cpc_handle_t sock)
{
    int rc;

    assert(numunchoked >= 1 && numunchoked <= numpeers);
    assert(GET_PEER(sock)->unchoked);

    debugf(2, "%3d choke\n", sock->cpch_handle);
    rc = send_choke(sock);
    if(rc < 0)
        return -1;
    free_chunks(sock);
    numunchoked--;
    GET_PEER(sock)->unchoked = 0;
    cpc_signal(choke_cond);
    return 1;
}

static cps int
send_chunk(cpc_handle_t sock, struct chunk *chunk)
{
    int file, i, rc;
    unsigned char buf[8];
    void *source;
    struct torrent *t = GET_PEER(sock)->t;
    int first, last;
    uint64_t offset;
    struct file *f;

    assert(GET_PEER(sock)->unchoked && GET_PEER(sock)->credit >= chunk->length);

    rc = find_chunk(t, chunk->offset * t->p_length + chunk->begin,
                    chunk->length, &first, &last, &offset, NULL);
    if(rc < 0) {
        debugf(1, "%3d couldn't find chunk\n", sock->cpch_handle);
        return -1;
    }

    if(first != last) {
        /* For simplicity, we always use a native thread for data that
           spans multiple files. */
        cpc_detached {
            return send_multi_chunk(sock, chunk, first, last, offset);
        }
    }

    source = malloc(chunk->length);
    cpc_read_at(sock, source, chunk->length, offset);

    debugf(3, "%3d send chunk: length=%d, offset=%lld\n",
           sock->cpch_handle, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);

    DO_HTONL(buf + 0, chunk->offset);
    DO_HTONL(buf + 4, chunk->begin);

    rc = send_message_2(sock, 7, buf, 8, source, chunk->length);
    if(rc < 0) {
        print_error("(send_chunk)write");
        goto fail;
    }

 done:
    debugf(3, "%3d sent chunk: length=%d, offset=%lld\n",
           sock->cpch_handle, chunk->length,
           (long long int)chunk->offset*t->p_length + chunk->begin);
    t->uploaded += chunk->length;
    GET_PEER(sock)->credit -= chunk->length;
    assert(GET_PEER(sock)->credit >= 0 && GET_PEER(sock)->credit < initial_credit);

    free(source);
    return 0;
 fail:
    perror("(send_chunk)write");
    free(source);
    return -1;
}

/* return -1 if sth wrong happend in handshake otherwise return 0 */
static cps int
handshake(hashtable *ht, cpc_handle_t sock)
{
    int rc, i;
    const char *protocol = "\023BitTorrent protocol";
    char *res = NULL, id[41];
    struct torrent *torrent = NULL;
    cpc_buffer *b = cpc_buffer_get(68);

    /* The wikified spec implies that we must send our handshake as soon as
       we get the info_hash, or risk a deadlock when the tracker performs
       its ``NAT check''.  No, I don't claim to understand it either. */

    rc = cpc_buffer_read(sock, b, 48);
    if(rc < 48) {
        perror("(handshake)cpc_partial_read");
        goto fail;
    }

    if(memcmp(b->buf, protocol, 20) != 0) {
        for(i = 0; i<20; i++) {
            unsigned char c = b->buf[i];
            snprintf(id + i, 2, "%c", c >= 0x21 && c <= 0x7E ? c : '.');
        }
        debugf(1, "%3d bad protocol: %s\n", sock->cpch_handle, id);
        goto fail;
    }

    torrent = ht_get(ht, b->buf + 28);
    if(!torrent) {
        debugf(2, "%3d cannot find hash: %s\n", sock->cpch_handle, id);
        goto fail;
    }

    for(i = 0; i<20; i++)
        snprintf(id + 2 * i, 3, "%.2x", (unsigned char)*(b->buf + 28 + i));

    debugf(2, "%3d torrent requested: %s\n", sock->cpch_handle, id);

    GET_PEER(sock)->t = torrent;
    GET_PEER(sock)->credit = 0;

    res = malloc(1 + 19 + 8 + 20 + 20);

    strncpy(res, protocol, 20);

    memset(res + 20, 0, 8);
    if(!nodht)
        res[20 + 7] |= 1;
    res[20 + 5] |= 0x10;

    memcpy(res + 28, torrent->info_hash, 20);
    memcpy(res + 48, peer_id, 20);

    rc = send_bitfield(sock, torrent, res, 68);
    free(res);
    if(rc < 0)
        goto fail;

    /* Read the rest of the client handshake. */
    rc = cpc_buffer_read(sock, b, 68);
    if(rc < 68)
        goto fail;

    GET_PEER(sock)->dht = !!(b->buf[1 + 19 + 7] & 1);
    GET_PEER(sock)->ltep = !!(b->buf[1 + 19 + 5] & 0x10);

    for(i = 0; i < 20; i++) {
        unsigned char c = b->buf[48 + i];
        snprintf(id + i, 2, "%c", c >= 0x21 && c <= 0x7E ? c : '.');
    }
    debugf(2, "%3d peer-id %s %s%s\n",
           sock->cpch_handle, id,
           GET_PEER(sock)->dht ? " (DHT)" : "",
           GET_PEER(sock)->ltep ? " (LTEP)" : "");

    cpc_buffer_destroy(b);
    return 0;

fail:
    cpc_buffer_destroy(b);
    return -1;
}

static cps void
stream_writer(cpc_handle_t sock)
{
    struct chunk *chunk;
    int rc;

    if(!nodht && GET_PEER(sock)->dht) {
        struct sockaddr_in6 sin6;
        socklen_t salen = sizeof(sin6);
        rc = getpeername(sock->cpch_handle, (struct sockaddr*)&sin6, &salen);
        if(rc < 0) {
            perror("getpeername");
        } else {
            if(sin6.sin6_family == AF_INET6 &&
               ((!noipv4 && IN6_IS_ADDR_V4MAPPED(&sin6.sin6_addr)) ||
                (!noipv6 && !IN6_IS_ADDR_V4MAPPED(&sin6.sin6_addr)))) {
                rc = send_dht_port(sock, peer_port);
                if(rc < 0)
                    goto done;
            }
        }
    }

    if(GET_PEER(sock)->ltep) {
        rc = send_ltep_handshake(sock, peer_port);
        if(rc < 0)
            goto done;
    }

    while(1) {
        assert(!GET_PEER(sock)->unchoked);

        while(numunchoked >= maxunchoked) {
            if(GET_PEER(sock)->dying)
                goto done;
            cpc_wait(choke_cond);
        }

        /* If the peer is a seed, it should have dropped the connection by
           now, in which case the reader will have noticed. */
        if(GET_PEER(sock)->dying)
            goto done;

        if(numpeers >= maxpeers - 1) {
            /* If our queue is full-ish, then this peer should have expressed
               interest before it reached this point.  If it's empty-ish,
               then we might as well unchoke it even though it's not interested,
               just for kicks. */
            if(!GET_PEER(sock)->interested) {
                debugf(2, "%3d dropping uninterested\n", sock->cpch_handle);
                goto done;
            }
        }

        rc = unchoke_peer(sock);
        if(rc < 0)
            goto done;

        while(1) {
            assert(GET_PEER(sock)->unchoked);

            if(GET_PEER(sock)->dying)
                goto done;

            if(!GET_PEER(sock)->list)
                cpc_sleep(30, 0, GET_PEER(sock)->writer_cond);

            if(!GET_PEER(sock)->list)
                /* Look, mate, you had your chance. */
                goto done;

            if(GET_PEER(sock)->dying)
                goto done;

            chunk = GET_PEER(sock)->list;

            if(chunk->length > initial_credit) {
                debugf(1, "%3d chunk larger than max credit!\n", sock);
                goto done;
            }

            if(chunk->length > GET_PEER(sock)->credit ||
               (max_unchoked_time > 0 &&
                GET_PEER(sock)->unchoke_time + max_unchoked_time < time(NULL))) {
                if(numpeers <= maxunchoked) {
                    debugf(2, "%3d replenish\n", sock);
                    GET_PEER(sock)->credit = initial_credit;
                } else {
                    /* Choke even if we're going to drop,
                       since we're not doing lingering close yet. */
                    rc = choke_peer(sock);
                    if(rc < 0)
                        goto done;

                    if(numpeers >= maxpeers) {
                        debugf(2, "%3d dropping\n", sock->cpch_handle);
                        goto done;
                    }

                    /* Give other peers a chance to become unchoked. */
                    cpc_yield();

                    break;
                }
            }

            assert(GET_PEER(sock)->list == chunk);
            GET_PEER(sock)->list = GET_PEER(sock)->list->next;
            rc = send_chunk(sock, chunk);
            free(chunk);
            if(rc < 0)
                goto done;
            cpc_yield();
        }
    }

 done:
    GET_PEER(sock)->dying = 1;
    shutdown(sock, 2);
    cpc_signal_fd(sock->cpch_handle, CPC_IO_IN);

    /* If we failed to unchoke the peer above, then a slot is still vacant. */
    if(numunchoked < maxunchoked)
        cpc_signal(choke_cond);

    cpc_barrier_await(GET_PEER(sock)->barrier);
}

static cps int
stream_reader(cpc_handle_t sock)
{
    uint32_t length = 0;
    cpc_buffer *b = cpc_buffer_get(BUF_LENGTH);
    uint32_t begin, index, chunk_len;
    int rc, type;

    while(1) {
        if(GET_PEER(sock)->dying)
            goto fail;


        rc = cpc_buffer_read(sock, b, 4);
        if(rc < 4)
            goto fail;

        assert(b->end - b->start >= 4);

        DO_NTOHL(length, b->buf + b->start);
        b->start += 4;

        if(length > BUF_LENGTH) {
            debugf(1, "%3d unbelievably long message (%d bytes)\n",
                   sock->cpch_handle, length);
            goto fail;
        }

        rc = cpc_buffer_read(sock, b, length);
        if(rc < (int32_t) length)
            goto fail;

        assert(b->end - b->start >= length);

        /* keep-alive */
        if(length == 0)
            continue;

        type = b->buf[b->start];

        debugf(10, "%3d <- type = %d, length = %d\n",
               sock->cpch_handle, type, length);

        if(type != 5 && type != 20 && length > 20) {
            debugf(1, "%3d unbelievably long message!\n", sock->cpch_handle);
            goto fail;
        }

        switch(type) {
        case 0: case 1: case 4: case 5: case 9: case 20:
            break;

        case 2:
            debugf(3, "%3d interested\n", sock->cpch_handle);
            GET_PEER(sock)->interested = 1;
            break;

        case 3:
            debugf(3, "%3d not interested\n", sock->cpch_handle);
            GET_PEER(sock)->interested = 0;
            goto fail;

        case 6:
        case 8:
            if(length < 13) {
                debugf(1, "%3d message too short\n");
                goto fail;
            }

            /* There's a race condition in the protocol: if a request and
               a choke cross each other, then the two peers will have
               unsynchronised request lists.  Ignoring any requests when
               the peer is choked mitigates the race somewhat, although it
               can still happen if we send choke/unchoke in short
               succession.  The peers will resynchronise at the next
               choke.

               The FAST extension solves the issue, but it's somewhat
               overkill. */
            if(!GET_PEER(sock)->unchoked) {
                debugf(2, "%3d %s in choked state\n",
                       sock->cpch_handle, type == 6 ? "request" : "cancel");
                assert(GET_PEER(sock)->list == NULL);
                break;
            }

            DO_NTOHL(index, b->buf + b->start + 1);
            DO_NTOHL(begin, b->buf + b->start + 5);
            DO_NTOHL(chunk_len, b->buf + b->start + 9);
            if(chunk_len == 0){
                debugf(1, "%3d request length is zero\n", sock->cpch_handle);
                goto fail;
            }
            debugf(3, "%3d %s: index = %u\tbegin = %u\tlength = %u\n",
                   sock->cpch_handle, type == 6 ? "request" : "cancel",
                   index, begin, chunk_len);
            if(chunk_len > LARGE_CHUNK) {
                debugf(1, "%3d unbelievably large chunk size requested\n");
                goto fail;
            }

            if(type == 6) {
                int rc, i, first, last;
                uint64_t offset, last_len;
                rc = find_chunk(GET_PEER(sock)->t,
                                index * GET_PEER(sock)->t->p_length + begin,
                                chunk_len,
                                &first, &last, &offset, &last_len);
                if(rc < 0) {
                    debugf(1, "%3d find_chunk fail\n", sock->cpch_handle);
                    goto fail;
                }
                GET_PEER(sock)->list = add_chunk(GET_PEER(sock)->list,
                                                 index, begin, chunk_len);
                cpc_signal(GET_PEER(sock)->writer_cond);
            } else {
                GET_PEER(sock)->list = remove_chunk(GET_PEER(sock)->list,
                                                    index, begin, chunk_len);
            }
            break;

        case 7:
            debugf(1, "%3d unexpected piece message\n", sock);
            goto fail;

        default:
            debugf(1, "%3d unexpected message\n", sock);
            goto fail;
        }
        b->start += length;
    }
 fail:
    cpc_buffer_destroy(b);
    return -1;
}

static void
free_chunk_list(struct chunk* c)
{
    struct chunk *next;
    while(c) {
        next = c->next;
        free(c);
        c = next;
    }
}

static void
free_chunks(cpc_handle_t sock)
{
    free_chunk_list(GET_PEER(sock)->list);
    GET_PEER(sock)->list = NULL;
    return ;
}

static cps void
client(hashtable *t, cpc_handle_t client_sock)
{
    int rc = 0;

    assert(GET_PEER(client_sock) == NULL || GET_PEER(client_sock)->t == NULL);

    GET_PEER(client_sock)->writer_cond = cpc_condvar_get();

    rc = handshake(t, client_sock);
    if(rc < 0) {
        debugf(1, "%3d broken handshake -- dropping\n", client_sock);
        goto done;
    }

    GET_PEER(client_sock)->barrier = cpc_barrier_get(2);

    cpc_spawn stream_writer(client_sock);

    rc = stream_reader(client_sock);

    GET_PEER(client_sock)->dying = 1;
    shutdown(client_sock->cpch_handle, 2);
    cpc_signal_fd(client_sock->cpch_handle, CPC_IO_OUT);
    cpc_signal(GET_PEER(client_sock)->writer_cond);
    cpc_barrier_await(GET_PEER(client_sock)->barrier);

 done:
    debugf(1, "%3d closing\n", client_sock);
    free_chunks(client_sock);
    GET_PEER(client_sock)->t = NULL;

    cpc_condvar_release(GET_PEER(client_sock)->writer_cond);

    if(GET_PEER(client_sock)->unchoked) {
        numunchoked--;
        cpc_signal(choke_cond);
    }

    assert(numpeers >= 1);
    remove_peer(client_sock);

    cpc_close_handle(client_sock);
    return;
}

cps void
listening(hashtable * table)
{
    cpc_handle_t serv_sock, client_sock;
    int rc, flags, one = 1, zero = 0;
    int64_t rc64;
    socklen_t cli_len;
    struct sockaddr_in6 serv_addr, cli_addr;

    maxpeers = maxunchoked * 10;

    serv_sock = cpc_open_socket_tcp(AF_INET6, 0);
    if(serv_sock == NULL) {
        print_error("cpc_open_socket_tcp");
        return;
    }

    rc = setsockopt(serv_sock->cpch_handle, IPPROTO_IPV6, IPV6_V6ONLY,
                    &zero, sizeof(zero));
    if(rc) {
        WSA_print_error("(listening)setsockopt(IPV6_V6ONLY)");
        return;
    }

    rc = setsockopt(serv_sock->cpch_handle, SOL_SOCKET, SO_REUSEADDR,
                    &one, sizeof(one));
    if(rc) {
        perror("(listening)setsockopt");
        return;
    }

    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin6_family = AF_INET6;
    serv_addr.sin6_port = htons(peer_port);

    rc = bind(serv_sock->cpch_handle, (struct sockaddr *)&serv_addr,
              sizeof(serv_addr));
    if(rc < 0)
        WSA_print_error("(listening)bind");

    rc = listen(serv_sock->cpch_handle, 20);
    if(rc < 0) {
        WSA_print_error("(listening)listen");
        return;
    }

    choke_cond = cpc_condvar_get();

    while(1) {
        client_sock = cpc_open_socket_tcp(AF_INET6, 0);
    again:
        rc64 = cpc_accept(serv_sock, client_sock, NULL, 0);
        if(rc64 < 0) {
            print_errno("accept", (long)-rc64);
            goto again;
        }
        debugf(2, "%3d accepted\n", client_sock->cpch_handle);

        assert(GET_PEER(client_sock)== NULL || GET_PEER(client_sock)->t== NULL);

        assert(numpeers >= 0 && numpeers <= maxpeers);
        if(numpeers >= maxpeers) {
            debugf(1, "%3d dropping early\n", client_sock->cpch_handle);
            goto fail;
        }

        rc = setsockopt(serv_sock->cpch_handle, SOL_SOCKET, SO_KEEPALIVE,
                        &one, sizeof(one));
        if(rc) {
            print_error("setsockopt");
            goto fail;
        }

        rc = add_peer(client_sock);
        if(rc < 0)
            goto fail;
        cpc_spawn client(table, client_sock);
        continue;

    fail:
        cpc_close_handle(client_sock);
        continue;
    }

    return;
}
